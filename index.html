<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Blood for Booty</title>
	<style>
		* {
			box-sizing: border-box;
			-ms-overflow-style: none;
			scrollbar-width: none;
		}
		::-webkit-scrollbar {
			display: none;
		}
		button {
			background-color: rgba(50,0,0,.8);
			color: moccasin;
			font-size: inherit;
			font-family: inherit;
			border: none;
			padding: .2em .5em;
			cursor: pointer;
			min-width: 2rem;
		}
		button:disabled {
			opacity: .5;
			cursor: not-allowed;
		}
		input {
			border-width: .1rem 0;
			color: inherit;
			font-family: inherit;
			font-size: 1rem;
			width: 3rem;
			text-align: center;
			background-color: papayawhip;
		}
	</style>
</head>
<body style="margin:0; height:100vh; display:flex; flex-direction:column; font-family:cursive; color:rgba(50,0,0,.8);">
<div style="background-color:maroon; color:white; padding:1rem; font-size:1.2rem;">
	<span>Grog: <span id="grog">0</span></span>
	<span>Booty: <span id="booty">0</span></span>
	<span>Heading: <span id="heading">Island</span></span>
</div>
<div style="height:0; flex-grow:1; display:flex; background-color:moccasin;">
	<div style="padding-bottom:2rem; width:20rem; height:100%; background-color:tan;">
		<div id="log" style="max-height:100%; padding:0 1rem; overflow:auto;"></div>
	</div>
	<div style="position:relative; height:100%; flex-grow:1; text-align:center;">
		<div id="watermark" style="
			font-size:20rem; font-family:monospace;
			position:absolute; width:100%; opacity:.5;"
		>â˜ </div>
		<div id="port-interface" style="display:none; padding:2rem; font-size:1.5rem;">
			<div>Port Actions</div>
			<div style="display:flex; flex-wrap:wrap; justify-content:center; font-size:1rem;">
				<div style="margin:1rem; border:.1rem solid; padding:1rem;">
					<div id="grog-purchase" style="margin-bottom:1rem;">
						Buy Grog for <span id="grog-price">1</span> Booty each
					</div>
				</div>
				<div style="margin:1rem; border:.1rem solid; padding:1rem;">
					<div>Booty stash</div>
					<div id="stash-inputs" style="text-align:left; display:inline-block;"></div>
				</div>
				<div style="margin:1rem; border:.1rem solid; padding:1rem;">
					<div>Recruit new crew member for 1 Booty and 1 Grog</div>
					<button onclick="recruitPirate(event)" style="margin-top:1rem;">Recruit</button>
				</div>
			</div>
			<button id="finished-port-button" style="margin-top:2rem;">Shove Off</button>
		</div>
		<div id="chooser" style="
			display:none; height:100%; width:30rem;
			flex-direction:column;
			padding:2rem; padding-bottom:4rem; font-size:1.5rem;
		">
			<div id="prompt">Prompt</div>
			<div style="font-size:1.2rem; padding:2rem 0; height:0; flex-grow:1; max-height:25rem;">
				<div id="description"></div>
				<div id="options" style="height:100%; display:flex; flex-direction:column; flex-wrap:wrap;"></div>
			</div>
			<button id="continue-button">Continue</button>
		</div>
		<div id="job-interface" style="display:none; height:100%; flex-direction:column; padding:2rem; font-size:1.5rem;">
			<div>Assign Jobs</div>
			<div id="job-area-holder" style="
				display:flex; justify-content:space-between;
				width:31rem; height:0; flex-grow:1;
				padding-bottom:1rem; font-size:1rem;
			"></div>
			<button id="finished-assignment-button">Continue</button>
		</div>
	</div>
</div>
<div style="height:15em; width:100vw; overflow-x:auto; padding:1rem; background-color:#222; color:white;">
	<div id="crew" style="display:inline-flex;"></div>
</div>

<script src="names.js"></script>
<script src="hairstyles.js"></script>
<script src="gameplay.js"></script>
<script src="misc-tables.js"></script>
<script src="crew-events.js"></script>
<script src="sea-encounters.js"></script>
<script src="island-exploration.js"></script>
<script src="port-happenings.js"></script>
<script>

function inflate(html) {
	var template = document.createElement('template');
	html = html.trim();
	template.innerHTML = html;
	return template.content.firstChild;
}

function clear(el) {
	while(el.firstChild) {
		el.removeChild(el.firstChild);
	}
}

async function recruitPirate(event) {
	event.target.disabled = true;
	if(grog >= 1 && booty >= 1) {
		incrementGrog(-1);
		incrementBooty(-1);
		await rollPirate();
		switchInterface('port');
	}
	event.target.disabled = false;
}

function updateNumberSelect(element) {
	let limits = element.blood4booty.limits;
	let minusButton = element.getElementsByClassName('minus-button')[0];
	let addButton = element.getElementsByClassName('plus-button')[0];
	let confirmButton = element.getElementsByClassName('confirm-button')[0];
	let input = element.getElementsByClassName('number-input')[0];
	let val = parseInt(input.value);
	confirmButton.disabled = val < limits.min || val > limits.max;
	minusButton.disabled = val <= limits.min;
	addButton.disabled = val >= limits.max;
}

function prepareNumberSelect(id, confirmText, listener) {
	let element = inflate(`
		<div id="${id}">
			<div style="display:inline-flex;">
				<button class="minus-button">-</button>
				<input class="number-input" type="text" value="0" />
				<button class="plus-button">+</button>
			</div>
			<button class="confirm-button">${confirmText}</button>
		</div>
	`);
	element.blood4booty = {};
	element.blood4booty.limits = { min:0, max:0 };
	let buttons = [ element.getElementsByClassName('minus-button')[0], element.getElementsByClassName('plus-button')[0] ];
	let confirmButton = element.getElementsByClassName('confirm-button')[0];
	let input = element.getElementsByClassName('number-input')[0];
	input.addEventListener('input', event => {
		input.value = input.value.replaceAll(/[^0-9]/g, '');
		let val = parseInt(input.value);
		updateNumberSelect(element);
	});
	buttons.forEach((button, i) => {
		button.addEventListener('click', () => {
			let val = parseInt(input.value) + (i == 0 ? -1 : 1);
			input.value = val;
			updateNumberSelect(element);
		});
	});
	confirmButton.addEventListener('click', () => {
		let limits = element.blood4booty.limits;
		let val = parseInt(input.value);
		if(val <= limits.max && val >= limits.min) {
			listener(val);
			input.value = '0';
		}
	});
	return element;
}

function updateJobLists() {
	let areas = {
		unassigned: document.getElementById('unassigned-area'),
		helm: document.getElementById('helm-area'),
		deck: document.getElementById('deck-area'),
		sails: document.getElementById('sails-area'),
	};
	Object.values(areas).forEach(clear);
	let team = {
		helm: crew.filter(p => p.job == 'helm'),
		deck: crew.filter(p => p.job == 'deck'),
		sails: crew.filter(p => p.job == 'sails'),
	};
	[...crew].sort((a,b) => a.lastMoved - b.lastMoved).forEach(pirate => {
		let nonWorking = cannotWork(pirate, pirate.job ? team[pirate.job] : []);
		let listItem = inflate(`
			<div
				draggable="${pirate.captain ? 'false' : 'true'}"
				style="
					user-select: none;
					cursor: ${pirate.captain ? 'not-allowed' : 'move'};
					${nonWorking ? 'opacity: .75;' : ''}
					background-color: #222;
					color: white;
					padding: .25rem;
					margin-bottom: .5rem;
				"
			>
				<div>${getPirateName(pirate)}${
					hasAttribute(pirate, flaw.scrapper) ? `<span style="margin-left:.25rem;">ðŸ’¢</span>` : ''
				}</div>
				${nonWorking ? `<div style="font-size:.6rem;">*${nonWorking}</div>` : ''}
			</div>
		`);
		listItem.addEventListener('dragstart', ev => {
			ev.dataTransfer.setData('text/plain', crew.indexOf(pirate).toString());
			ev.dataTransfer.dropEffect = 'move';
		});
		areas[pirate.job || 'unassigned'].appendChild(listItem);
	});
}

function updateCrewList() {
	let holder = document.getElementById('crew');
	// remove excess pirates from list
	while(holder.children.length > crew.length) {
		holder.removeChild(holder.children[holder.children.length-1]);
	}
	for(let i=0; i<crew.length; i++) {
		let pirate = crew[i];
		let element = holder.children[i]; // try to re-use existing elements where possible
		let nameText = getPirateName(pirate);
		let attributeText = pirate.attributes.map(attr => attr.name).join(', ');
		if(element) {
			element.getElementsByClassName('name')[0].textContent = nameText;
			element.getElementsByClassName('overlay')[0].setAttribute('title', attributeText);
		} else {
			// create new element if there aren't enough existing ones
			element = inflate(`
				<div style="position:relative; text-align:center; width:7rem;">
					<object class="graphic" type="image/svg+xml" data="pirate.svg" style="display:inline-block; height:6rem; opacity:0;">pirate graphic</object>
					<div class="name">${nameText}</div>
					<div class="overlay" style="position:absolute; top:0; left:0; width:100%; height:100%;" title="${attributeText}"></div>
				</div>
			`);
			holder.appendChild(element);
		}
		let graphic = element.getElementsByClassName('graphic')[0];
		if(graphic.style.opacity == 1) { // if opacity is 1, that means the svg has loaded, so we can just update it
			updatePirateEl(pirate, graphic.contentDocument);
		} else { // otherwise, we need to wait for the svg to load first
			graphic.addEventListener('load', () => {
				updatePirateEl(pirate, graphic.contentDocument);
				graphic.style.opacity = 1;
			}, false);
		}
	}
}

function setSvgElVisibility(el, visible) {
	el.style.display = visible ? 'inline' : 'none';
}

function updatePirateEl(pirate, el) {
	let elementIdAttributePairs = [
		['sabre', skill.swashbucklin],
		['hat', skill.swaggerin],
		['treasure', skill.stealin],
		['pistol', skill.shootin],
		['parrot', feature.parrot],
		['single-tooth', feature.toothless],
		['eyepatch', feature.eyepatch],
		['beard', feature.beard],
		['peg-leg', feature.pegLeg],
		['hook', feature.hook],
		['left-hook', feature.leftHook],
		['tattoos', feature.tattoos],
		['monkey', feature.monkey],
		['sick-bubbles', flaw.seasick],
		['drunk-blush', flaw.swigger],
		['nose-dirt', flaw.scummy],
		['face-dirt', flaw.scummy],
		['arm-dirt', flaw.scummy],
		['bruise', flaw.scrapper],
		['crab', feature.crab],
		['crab-leg', feature.crab],
		['rat', feature.rat],
	];
	for(let pair of elementIdAttributePairs) {
		setSvgElVisibility(el.getElementById(pair[0]), hasAttribute(pirate, pair[1]));
	}
	let hiddenElementIdAttributePairs = [
		['hand', feature.hook],
		['left-hand', feature.leftHook],
		['left-boot', feature.pegLeg],
		['nose', feature.noNose],
		['teeth', feature.toothless],
		['eyebrows', flaw.scaredy],
	];
	for(let pair of hiddenElementIdAttributePairs) {
		setSvgElVisibility(el.getElementById(pair[0]), !hasAttribute(pirate, pair[1]));
	}
	let eyes = [ el.getElementById('eye'), el.getElementById('left-eye') ];
	let targetColor = hasAttribute(pirate, feature.blind) ? 'white' : 'black';
	for(let eyeEl of eyes) {
		eyeEl.style.fill = targetColor;
	}
	let mouth = el.getElementById('full-mouth');
	mouth.style.transform = hasAttribute(pirate, flaw.scaredy) ? 'scale(1, -1) translateY(-85%)' : '';
	let topClothes = [ el.getElementById('shirt'), el.getElementById('bandanna') ];
	for(let topEl of topClothes) {
		topEl.style.fill = pirate.colors[1];
	}
	el.getElementById('pants').style.fill = pirate.colors[2];
	for(let hairId of hairIds) {
		el.getElementById(hairId).style.fill = pirate.colors[0];
	}
	for(let hairId of hairParts) {
		let shown = pirate.hair.parts.includes(hairId) &&
			!(hasAttribute(pirate, skill.swaggerin) && (hairId == 'hair-poof' || hairId == 'hair-curly-back'))
		;
		setSvgElVisibility(el.getElementById(hairId), shown);
	}
}

function updateTopBar() {
	document.getElementById('grog').textContent = grog;
	document.getElementById('booty').textContent = booty+(stashedBooty ? ` [${stashedBooty} stashed]` : '');
	let cap = getCaptain();
	document.getElementById('heading').textContent = (cap && cap.permanentFlags.has('whale_obsession')) ?
		'White Whale' : (headingToIsland ? 'Island' : 'Port')
	;
}

async function addToLog(message, wait = 1000) {
	return new Promise(resolve => {
		let logEl = document.getElementById('log');
		let entry = inflate(`<div style="background-color:moccasin; margin-top:.5rem; padding:.5rem;">${message}</div>`);
		logEl.appendChild(entry);
		entry.scrollIntoView({ behavior: "smooth", block: "end" });
		window.setTimeout(resolve, wait);
	});
}

function clearLog() {
	let logEl = document.getElementById('log');
	clear(logEl);
}

function switchInterface(interface) {
	let watermark = document.getElementById('watermark');
	let eventInterface = document.getElementById('chooser');
	let portInterface = document.getElementById('port-interface');
	let jobInterface = document.getElementById('job-interface');
	eventInterface.style.display = 'none';
	portInterface.style.display = 'none';
	jobInterface.style.display = 'none';
	watermark.style.display = 'none';
	switch(interface) {
		case 'event':
			eventInterface.style.display = 'inline-flex';
			break;
		case 'job':
			jobInterface.style.display = 'inline-flex';
			break;
		case 'port':
			portInterface.style.display = 'block';
			break;
		default:
			watermark.style.display = 'block';
			break;
	}
}

function updatePort(maxTradeAmount=Infinity) {
	// initial setup
	if(!document.getElementById('grog-purchase-selector')) {
		let grogAmountSelector = prepareNumberSelect('grog-purchase-selector', 'Buy', purchaseCount => {
			incrementBooty(-Math.ceil(getGrogPrice()*purchaseCount));
			incrementGrog(purchaseCount);
		});
		document.getElementById('grog-purchase').after(grogAmountSelector);
	}
	let stashContainer = document.getElementById('stash-inputs');
	if(stashContainer.children.length == 0) {
		let select = prepareNumberSelect('stash-deposit', 'Deposit', value => {
			incrementBooty(-value);
			incrementStashedBooty(value);
		});
		select.style.marginTop = '1rem';
		stashContainer.appendChild(select);
		select = stashContainer.appendChild(prepareNumberSelect('stash-withdraw', 'Withdraw', value => {
			incrementStashedBooty(-value);
			incrementBooty(value);
		}));
		select.style.marginTop = '1rem';
		stashContainer.appendChild(select);
	}
	// grog price
	let grogPrice = getGrogPrice();
	document.getElementById('grog-price').textContent = grogPrice.toString();
	// grog purchase selector
	let selector = document.getElementById('grog-purchase-selector');
	selector.blood4booty.limits.max = Math.min(maxTradeAmount, shipWeeklyFlags.has('no_grog_sale') ? 0 : (booty / grogPrice));
	updateNumberSelect(selector);
	// stash selectors
	selector = document.getElementById('stash-deposit');
	selector.blood4booty.limits.max = Math.min(maxTradeAmount, booty);
	updateNumberSelect(selector);
	selector = document.getElementById('stash-withdraw');
	selector.blood4booty.limits.max = stashedBooty;
	updateNumberSelect(selector);
}

async function doPortActions() {
	updatePort();
	switchInterface('port');
	let button = document.getElementById('finished-port-button');
	return new Promise((resolve, reject) => {
		let listenerName = 'click';
		let listener = event => {
			switchInterface();
			button.removeEventListener(listenerName, listener);
			resolve();
		};
		button.addEventListener(listenerName, listener);
	});
}
function updateEventText(prompt, description) {
	let promptEl = document.getElementById('prompt');
	promptEl.textContent = prompt;
	let descriptionEl = document.getElementById('description');
	descriptionEl.textContent = description;
	descriptionEl.style.display = description ? 'block' : 'none';
}

async function getNumberInput(prompt, description, confirmText, min, max) {
	switchInterface('event');
	updateEventText(prompt, description);
	return new Promise((resolve, reject) => {
		let button = document.getElementById('continue-button');
		button.style.display = 'none';
		let optionHolder = document.getElementById('options');
		optionHolder.style.display = 'block';
		let select = prepareNumberSelect('event-number-chooser', confirmText, val => {
			switchInterface();
			button.style.display = 'inline';
			clear(optionHolder);
			resolve(val);
		});
		select.style.marginTop = '1rem';
		select.blood4booty.limits.max = max;
		select.blood4booty.limits.min = min;
		optionHolder.appendChild(select);
	});
}

function updateOptions(options, onSelected, singleSelect=false) {
	let optionHolder = document.getElementById('options');
	optionHolder.style.display = options == null ? 'none' : 'flex';
	clear(optionHolder);
	if(!options) {
		return;
	}
	for(let opt of options) {
		let optEl = inflate(`
			<div style="position:relative; cursor:pointer; align-self:center;">
				<span style="position:absolute; left:-1em;">${opt.selected ? 'âœ”' : ''}</span>
				<span>${opt.text}</span>
			</div>
		`);
		optionHolder.appendChild(optEl);
		optEl.addEventListener('click', async () => {
			if(singleSelect) {
				options.forEach(o => o.selected = false);
			}
			opt.selected = !opt.selected;
			updateOptions(options, onSelected, singleSelect);
			if(onSelected) {
				onSelected();
			}
		});
	}
}

async function doAction(prompt, description, continueText, options, singleSelect, onSelected) {
	switchInterface('event');
	// basic text
	updateEventText(prompt, description);
	// button
	let buttonDisabled = onSelected ? !onSelected() : false;
	let button = document.getElementById('continue-button');
	button.textContent = continueText || 'Continue';
	button.disabled = buttonDisabled;
	// options
	updateOptions(options, onSelected ? (() => {
		let validSelection = onSelected();
		buttonDisabled = !validSelection;
		button.disabled = buttonDisabled;
	}) : null, singleSelect);
	// handle continue
	return new Promise((resolve, reject) => {
		let listenerName = 'click';
		let listener = event => {
			if(!buttonDisabled) {
				switchInterface();
				button.removeEventListener(listenerName, listener);
				resolve();
			}
		};
		button.addEventListener(listenerName, listener);
	});
}

// if "exact", then "number" options must be selected, otherwise, up to "number" may be selected
async function getChoice(prompt, options, exact=true, number=null, auto=false) {
	if(number == null && exact) {
		number = 1; // default to 1 ONLY for exact value choices
	}
	if(auto || (options.length == number && exact) || (options.length == 1 && !exact)) {
		let selected = [];
		while(selected.length < number && selected.length < options.length) {
			selected.push(randomResult(options, selected));
		}
		let values = selected.map(opt => opt.value);
		return number == 1 ? values[0] : values;
	}
	await doAction(
		prompt, '', 'Confirm',
		options, number == 1,
		() => {
			let selected = options.filter(opt => opt.selected);
			return selected.length == number || (!exact && (number == null || selected.length < number));
		},
	);
	let selected = options.filter(opt => opt.selected);
	let values = selected.map(opt => opt.value);
	return number == 1 ? values[0] : values;
}

async function doJobAssignments() {
	updateJobLists();
	switchInterface('job');
	let button = document.getElementById('finished-assignment-button');
	return new Promise((resolve, reject) => {
		let listenerName = 'click';
		let listener = event => {
			switchInterface();
			button.removeEventListener(listenerName, listener);
			resolve();
		};
		button.addEventListener(listenerName, listener);
	});
}

function pirateToOption(pirate, selected = false) {
	return { value:pirate, text:getPirateName(pirate), selected:selected };
}

function pirateOptions(pirateGroup) {
	return pirateGroup.map(p => pirateToOption(p));
}

async function showEvent(event, type, arg) {
	let logPromise = addToLog(`${type}: ${event.name}`);
	await doAction(event.name, event.description || '', event.continueText);
	let result = await event.handler(arg);
	await logPromise;
	if(result && result.description) {
		await doAction(event.name, result.description, result.continueText);
	}
}

// initial UI setup
let jobs = [
	{
		id: 'helm',
		name: 'Helm',
	},
	{
		id: 'deck',
		name: 'Deck',
	},
	{
		id: 'sails',
		name: 'Sails',
	},
	{
		id: 'unassigned',
		name: 'No Job',
	},
];
let jobHolder = document.getElementById('job-area-holder');
jobs.forEach(job => {
	let area = inflate(`
		<div style="display:flex; flex-direction:column; width:7rem;">
			<div>${job.name}</div>
			<div id="${job.id}-area" style="background-color:tan; flex-grow:1; overflow:auto; padding:.5rem;"></div>
		</div>
	`);
	area.addEventListener('dragenter', ev => { ev.preventDefault(); return false; });
	area.addEventListener('dragover', ev => { ev.preventDefault(); return false; });
	area.addEventListener('drop', ev => {
		ev.preventDefault();
		if(job.id != 'helm' || crew.filter(p => p.job == 'helm').length < 2) {
			let index = parseInt(ev.dataTransfer.getData('text/plain'));
			let pirate = crew[index];
			let newJob = job.id == 'unassigned' ? null : job.id;
			if(pirate.job != newJob) {
				pirate.job = newJob;
				pirate.lastMoved = Date.now();
				updateJobLists();
			}
		}
	});
	jobHolder.appendChild(area);
});

// start game
beginGame();

</script>
</body>
</html>